#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    effectorPitchP, sensorPotentiometer)
#pragma config(Sensor, dgtl1,  secondaryArmE,  sensorQuadEncoder)
#pragma config(Sensor, dgtl5,  touch,          sensorTouch)
#pragma config(Sensor, dgtl6,  effectorPitchE, sensorQuadEncoder)
#pragma config(Sensor, dgtl10, millCOM,        sensorDigitalOut)
#pragma config(Sensor, dgtl11, eStop,          sensorTouch)
#pragma config(Sensor, dgtl12, viceP,          sensorDigitalOut)
#pragma config(Sensor, I2C_1,  mainArmE,       sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_2,  rotationE,      sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Sensor, I2C_3,  effectorYawE,   sensorQuadEncoderOnI2CPort,    , AutoAssign )
#pragma config(Motor,  port1,           test,          tmotorVex269_HBridge, openLoop)
#pragma config(Motor,  port2,           mainArmM,      tmotorVex393_MC29, PIDControl, encoderPort, I2C_1)
#pragma config(Motor,  port3,           effectorPitchM, tmotorVex269_MC29, PIDControl, reversed, encoderPort, dgtl6)
#pragma config(Motor,  port4,           effectorClawM, tmotorVex269_MC29, openLoop)
#pragma config(Motor,  port5,           rotationM,     tmotorVex269_MC29, PIDControl, encoderPort, I2C_2)
#pragma config(Motor,  port6,           mainArmSlaveM, tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port7,           secondaryArmM, tmotorVex269_MC29, PIDControl, encoderPort, dgtl1)
#pragma config(Motor,  port8,           effectorYawM,  tmotorVex269_MC29, PIDControl, reversed, encoderPort, I2C_3)
#pragma config(Motor,  port9,            ,             tmotorVex269_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

//Variables--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Variables
//Keyboard Interface--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Keyboard Interface
const int ctrl = 128
const int shift = 129;
const int alt = 134;
const int return_Arrow = 196
const int up_Arrow = 218;
const int down_Arrow = 217;
const int left_Arrow = 216;
const int right_Arrow = 215;
int charToSend;
//LCD Screen------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------LCD Screen
string tempString = "";
string readoutString = "";
int loopCount = 0;
int mainMenuLevel = 0;
int menuLevel = 0;
int subMenuLevel = 0;
int subSubMenuLevel = 0;
string motorNames[4] = {"Rotation", "Main Arm", "Second Arm", "Effector Pitch"};
const short leftButton = 1;
const short centerButton = 2;
const short rightButton = 4;
//Character Definition----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Character Definition
const int downArrow = 198;
const int upArrow = 197;
const int rightArrow = 199;
const int leftArrow = 200;
const int clear = 32;
const int backArrow = 196;
//PID Control----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------PID Control
int error[5] = {0,0,0,0,0};
int integral[5] = {0,0,0,0,0};
int derivative[5] = {0,0,0,0,0};
int prevError[5] = {0,0,0,0,0};
float kP[5] = {1,1,1,1,1};
float kI[5] = {1,1,1,1,1};
float kD[5] = {1,1,1,1,1};
//Motor and Posistion Control--------------------------------------------------------------------------------------------------------------------------------------------------------------------Motor and Posistion Control
const int moveToPosistionSpeed = 40;
int gripState = 0;
int motorDefinitions[5] = {rotationM, mainArmM, secondaryArmM, effectorPitchM, effectorYawM};
int motorSpeeds[10] = {0,0,0,0,0,0,0,0,0,0};
int motorEncoders[6] = {rotationE,mainArmE,secondaryArmE,effectorPitchM,effectorYawM,0};
float slewRate = 0.25;
const int home = 0;
const int aboveVice = 5;
const int vice = 10;
const int abovePickup = 15;
const int pickup = 20;
const int dropOff = 25;
int posistionArray[30] = {

	0,1,2,3,4,			//home
	5,6,7,8,9,	   		//above vice
	10,12,13,14,15, 		//vice
	15,16,17,18,19,			//above pickup
	20,21,22,23,24,			//pickup
	25,26,27,28,29			//drop off
};
int moveComplete[5];
//Vaccuum and Vice------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Vaccuum and Vice
int vacuumState = 0; //0=OFF 1=ON
int viceState = 0; //0=RELEASED 1=CLAMPED
//Serial Link----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Serial Link
char incomingChar;
int incomingByte[5];
string byteString = "";
int tentativeByte;
int receiveSign;
int receiveLength;
int incomingData[5];
long receiveData;
int receiveMeaning;
int byteCount = 0;
int tempCount = 0;
int temporaryString;
int sendSign;
int sendArray[5];
int sendNumber = 0;
int reveiveLength;
int receivedPosistions = 0;
int targetLocation[6];
int flushVar;
bool continuity = false;
float sendDelay = 4;
//Functions--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Functions
//Motor Slew Control--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Motor Slew Control
void motorSlewed(int targetMotor, int speed) {
	if (speed == motorSpeeds[targetMotor]) {
		return;
	}
	if (speed > 0) {
		if(motorSpeeds[targetMotor] < 0) {
			motor[targetMotor] = 0;
			motorSpeeds[targetMotor] = 0;
		}
		else if(motorSpeeds[targetMotor] > speed) {
			motor[targetMotor] = speed;
			motorSpeeds[targetMotor] = speed;
		}
		for(int i = motorSpeeds[targetMotor]; i <= speed; i++) {
			motor[targetMotor] = i;
			motorSpeeds[targetMotor] = i;
			wait1Msec(slewRate);
		}
		return;
	}
	else if(speed < 0) {
		if(motorSpeeds[targetMotor] > 0) {
			motor[targetMotor] = 0;
			motorSpeeds[targetMotor] = 0;
		}
		else if(motorSpeeds[targetMotor] < speed) {
			motor[targetMotor] = speed;
			motorSpeeds[targetMotor] = speed;
		}
		for(int i = motorSpeeds[targetMotor]; i >= speed; i--) {
			motor[targetMotor] = i;
			motorSpeeds[targetMotor] = i;
			wait1Msec(slewRate);
		}
		return;
	}
	else {
		motor[targetMotor] = 0;
		motorSpeeds[targetMotor] = 0;
		return;
	}
}
//Posistion PID Control----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Motor PID Control
void PIDToUndefinedPosistion(int speed, int rotation, int mainArm, int secondaryArm, int effectorYaw, int effectorPitch) {
	while(true) {
		error[0] = rotation - SensorValue(rotationE);
		error[1] = mainArm - SensorValue(mainArmE);
		error[2] = secondaryArm - SensorValue(secondaryArmE);
		error[3] = effectorYaw - SensorValue(effectorYawE);
		error[4] = effectorPitch - SensorValue(effectorPitchE);
		for(int i = 0; i < 5; i++) {
			integral[i] = integral[i] + error[i];
		}
		for(int i = 0; i < 5; i++) {
			if(error[i] == 0) {
				integral[i] = 0;
			}
		}
		for(int i = 0; i < 5; i++) {
			if(error[i] > 1000) {
				integral[i] = 0;
			}
		}
		for(int i = 0; i < 5; i++) {
			derivative[i] = error[i] - prevError[i];
		}
		for(int i = 0; i < 5; i++) {
			prevError[i] = error[i];
		}
		motorSlewed(rotationM, error[0]*kP[0] + integral[0]*kI[0] + derivative[0]*kD[0]);
		motorSlewed(mainArmM, error[1]*kP[1] + integral[1]*kI[1] + derivative[1]*kD[1]);
		motorSlewed(secondaryArmM, error[2]*kP[2] + integral[2]*kI[2] + derivative[2]*kD[2]);
		motorSlewed(effectorYawM, error[3]*kP[3] + integral[3]*kI[3] + derivative[3]*kD[3]);
		motorSlewed(effectorPitchM, error[4]*kP[4] + integral[4]*kI[4] + derivative[4]*kD[4]);
		delay(15);
	}
}
//Arm Posistion Control--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Arm Posistion Control
void moveToUndefinedPosistion(int speed, int rotation, int mainArm, int secondaryArm, int effectorYaw, int effectorPitch, bool holdPosistion) {
	setMotorTarget(rotationM, rotation, (speed)*.5, holdPosistion);
	setMotorTarget(mainArmM, mainArm, (speed)*1.5, holdPosistion);
	setMotorTarget(secondaryArmM, secondaryArm, speed*.25, holdPosistion);
	setMotorTarget(effectorYawM, effectorYaw, (speed)*2, holdPosistion);
	setMotorTarget(effectorPitchM, effectorPitch, (speed)*.5, holdPosistion);
	waitUntil(getMotorTargetCompleted(rotationM));
	waitUntil(getMotorTargetCompleted(mainArmM));
	waitUntil(getMotorTargetCompleted(secondaryArmM));
	waitUntil(getMotorTargetCompleted(effectorYawM));
	waitUntil(getMotorTargetCompleted(effectorPitchM));
}

void moveToDefinedPosistion(int speed, int posistion, bool holdPosistion) {
	moveToUndefinedPosistion(speed, posistionArray[posistion], posistionArray[posistion + 1], posistionArray[posistion + 2], posistionArray[posistion + 3], posistionArray[posistion + 4], holdPosistion);
}
//Keyboard Control------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Keyboard Control
void sendKeystroke(char key) {
	sendChar(UART1, 254);
	sendChar(UART1, key)
	sendChar(UART1, 255);
}
//Vice Control--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Vice Control
void actuateVice(int state) {
	if(state == 1) {
		SensorValue(viceP) = 1;
		viceState = 1;
	}
	else if(state == 0) {
		SensorValue(viceP) = 0;
		viceState = 0;
	}
}
//Mill Interface----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Mill Interface
void cycleStartMill() {
	SensorValue(millCOM) = 1;
	delay(500);
	SensorValue(millCOM) = 0;
}
void stopMill() {
	sendKeystroke(1);	//Send alt key
}
void rewindMill() {
	sendKeystroke(2); //Send crtl key
}
//Serial Link----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Serial Link
void setPosistionFromSerial(int posistionStart) {
	switch(receivedPosistions) {
	case 0:
		posistionArray[posistionStart] = receiveData;
		receivedPosistions++;
		break;
	case 1:
		posistionArray[posistionStart + 1] = receiveData;
		receivedPosistions++;
		break;
	case 2:
		posistionArray[posistionStart + 2] = receiveData;
		receivedPosistions++;
		break;
	case 3:
		posistionArray[posistionStart + 3] = receiveData;
		receivedPosistions++;
		break;
	case 4:
		posistionArray[posistionStart + 4] = receiveData;
		receivedPosistions++;
		receivedPosistions = 0;
		writeDebugStream("%d",posistionArray[0]);
		writeDebugStream("%d",posistionArray[1]);
		writeDebugStream("%d",posistionArray[2]);
		writeDebugStream("%d",posistionArray[3]);
		writeDebugStream("%d",posistionArray[4]);
		break;
	}
}

void sendSerial(int sendDestination, int sendPurpose, int sendData) {
	sendSign = sgn(sendData);
	if(sendSign == -1) {
		sendSign = 100;
	}
	else {
		sendSign = 0;
	}
	sendData = abs(sendData);
	sendChar(UART1, 254);
	delay(sendDelay);
	sendChar(UART1, sendPurpose);
	delay(sendDelay);
	sendArray[2] = (sendData/10000);
	sendArray[1] = ((sendData - (sendData / 10000) * 10000) / 100);
	sendArray[0] = sendSign + ((sendData - (sendData - ((sendData / 10000) * 10000) - (((sendData - ((sendData / 10000)) * 10000) - ((sendData / 100)) * 100)))));
	for(int i = 0; i < 3; i++) {
		sendChar(UART1, sendArray[i]);
		delay(sendDelay);
	}
	sendChar(UART1, 255);
	delay(sendDelay);
}
void flushSerialReceiveBuffer() {
	for(int i=0; i < 1000; i++) {
		flushVar = getChar(UART1);
	}
}
void actuateClaw(int speed, int state) {
	if(state == 1) {
		motor[effectorClawM] = speed;
	}
	else if(state == 0) {
		motor[effectorClawM] = -speed;
		delay(1000);
		motor[effectorClawM] = 0;
	}
}
void runBatch(int runCount) {
	for(int i = 0; i < runCount; i++) {
		displayLCDCenteredString(0, "RUN BATCH");
		moveToDefinedPosistion(moveToPosistionSpeed, home, true);
		displayLCDCenteredString(1, "At home");
		actuateClaw(0, 35);
		moveToDefinedPosistion(moveToPosistionSpeed, pickup, true);
		displayLCDCenteredString(1, "At pickup");
		moveToDefinedPosistion(moveToPosistionSpeed, abovePickup, true);
		actuateClaw(1, 35)
		moveToDefinedPosistion(moveToPosistionSpeed, aboveVice, true);
		actuateClaw(0, 35);
		delay(1000);
		actuateVice(0);
		moveToDefinedPosistion(moveToPosistionSpeed, home, true);
		cycleStartMill();
		delay(1000);
		cycleStartMill();
		delay(1000);
		moveToDefinedPosistion(moveToPosistionSpeed, aboveVice, true);
		actuateClaw(0, 35);
		moveToDefinedPosistion(moveToPosistionSpeed, vice, true);
		actuateClaw(1, 35);
		moveToDefinedPosistion(moveToPosistionSpeed, aboveVice, true);
		moveToDefinedPosistion(moveToPosistionSpeed, pickup, true);
		actuateClaw(0, 35);
	}
}
void vacuumPower(int state) {
}
//Tasks----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------TASKS
task lcdScreenControl() {
	bLCDBacklight = true;
	clearLCDLine(0);
	clearLCDLine(1);
	while(true) {
		//Intro Screen----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Intro Screen
		if (mainMenuLevel == 0) {
			displayLCDCenteredString(0, "Auto Mill");
			displayLCDCenteredString(1, "Beta 1.1.2");
			while(true) {
				if(nLCDButtons != 0) {
					mainMenuLevel = 1;
					wait1Msec(300);
					break;
				}
			}
		}
		//Run Screen--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Run Screen
		else if(mainMenuLevel == 1) {
			while(true) {
				displayLCDCenteredString(0, "Run Batch");
				displayLCDCenteredString(1, "Select");
				displayLCDChar(1,14, rightArrow);
				if(nLCDButtons == rightButton) {
					displayLCDCenteredString(0, "VAV Control");
					displayLCDCenteredString(1, "Select");
					displayLCDChar(1,1, leftArrow);
					displayLCDChar(1,14, rightArrow);
					mainMenuLevel = 2;
					wait1Msec(300);
					break;
				}
				wait1Msec(10);
			}
		}
		//VAV Control------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------VAV Control
		else if(mainMenuLevel == 2) {
			while(true) {
				displayLCDCenteredString(0, "VAV Control");
				displayLCDCenteredString(1, "Select");
				displayLCDChar(1,1, leftArrow);
				displayLCDChar(1,14, rightArrow);
				if(nLCDButtons == leftButton) {
					displayLCDCenteredString(0, "Run Batch");
					displayLCDCenteredString(1, "Select");
					displayLCDChar(1,14, rightArrow);
					mainMenuLevel = 1;
					wait1Msec(300);
					break;
				}
				else if(nLCDButtons == centerButton) {
					displayLCDCenteredString(0, motorNames[subMenuLevel]);
					displayLCDCenteredString(1, "Select");
					displayLCDChar(1,1,leftArrow);
					displayLCDChar(1,14,rightArrow);
					wait1Msec(300);
					while(true) {
						if(nLCDButtons == rightButton && subMenuLevel >= 3 && subMenuLevel < 6) {
							subMenuLevel++;
							if(subMenuLevel == 4) {
								displayLCDCenteredString(0,"Grip Control");
								displayLCDCenteredString(1, "Select");
								displayLCDChar(1,1,leftArrow);
								displayLCDChar(1,14,rightArrow);
							}
							if(subMenuLevel == 5) {
								displayLCDCenteredString(0, "Vacuum State");
								displayLCDCenteredString(1, "Select");
								displayLCDChar(1,1,leftArrow);
								displayLCDChar(1,14,rightArrow);
							}
							else if(subMenuLevel == 6) {
								displayLCDCenteredString(0, "Vice State");
								displayLCDCenteredString(1, " Select");
								displayLCDChar(1,1,leftArrow);
								displayLCDChar(1,14,rightArrow);
							}
							else if(subMenuLevel == 7) {
								displayLCDCenteredString(0, "Mill Interface");
								displayLCDCenteredString(1, "Select");
								displayLCDChar(1,1,leftArrow);
								displayLCDChar(1,14,rightArrow);
							}
							wait1Msec(300);
						}
						else if(nLCDButtons == leftButton && subMenuLevel >=3) {
							subMenuLevel--;
							if(subMenuLevel == 3 || subMenuLevel == 2) {
								displayLCDCenteredString(0, motorNames[subMenuLevel]);
								displayLCDCenteredString(1, "Select");
								displayLCDChar(1,1,leftArrow);
								displayLCDChar(1,14,rightArrow);
							}
							if(subMenuLevel == 4) {
								displayLCDCenteredString(0,"Grip Control");
								displayLCDCenteredString(1, "Select");
								displayLCDChar(1,1,leftArrow);
								displayLCDChar(1,14,rightArrow);
							}
							if(subMenuLevel == 5) {
								displayLCDCenteredString(0, "Vacuum State");
								displayLCDCenteredString(1, "Select");
								displayLCDChar(1,1,leftArrow);
								displayLCDChar(1,14,rightArrow);
							}
							else if(subMenuLevel == 6) {
								displayLCDCenteredString(0, "Vice State");
								displayLCDCenteredString(1, "Select");
								displayLCDChar(1,1,leftArrow);
								displayLCDChar(1,14,rightArrow);
							}
							else if(subMenuLevel == 7) {
								displayLCDCenteredString(0, "Mill Interface");
								displayLCDCenteredString(1, "Select");
								displayLCDChar(1,1,leftArrow);
								displayLCDChar(1,14,rightArrow);
							}
							wait1Msec(300);
						}
						else if(nLCDButtons == rightButton && subMenuLevel < 3) {
							subMenuLevel++;
							displayLCDCenteredString(0, motorNames[subMenuLevel]);
							displayLCDCenteredString(1, "Select");
							displayLCDChar(1,1,leftArrow);
							displayLCDChar(1,14,rightArrow);
							wait1Msec(300);
						}
						else if(nLCDButtons == leftButton && subMenuLevel > 0) {
							subMenuLevel--;
							displayLCDCenteredString(0, motorNames[subMenuLevel]);
							displayLCDCenteredString(1, "Select");
							displayLCDChar(1,1,leftArrow);
							displayLCDChar(1,14,rightArrow);
							wait1Msec(300);
						}
						else if(nLCDButtons == 5) {
							displayLCDCenteredString(0, "VAV Control");
							displayLCDCenteredString(1, "Select");
							displayLCDChar(1,1, leftArrow);
							displayLCDChar(1,14, rightArrow);
							wait1Msec(600);
							break;
						}
						else if(nLCDButtons == centerButton) {
							if(subMenuLevel <= 3 && subMenuLevel >= 0) {
								displayLCDCenteredString(0, motorNames[subMenuLevel]);
								stringFormat(readoutString,"%d",SensorValue(motorEncoders[subMenuLevel]));
								displayLCDCenteredString(1, readoutString);
								displayLCDChar(1,1,downArrow);
								displayLCDChar(1,14,upArrow);
								wait1Msec(300);
								while(true) {
									displayLCDCenteredString(0, motorNames[subMenuLevel]);
									stringFormat(readoutString,"%d",SensorValue(motorEncoders[subMenuLevel]));
									displayLCDCenteredString(1, readoutString);
									displayLCDChar(1,1,downArrow);
									displayLCDChar(1,14,upArrow);
									if(nLCDButtons == leftButton) {
										displayLCDChar(1,1, clear);
										stringFormat(readoutString,"%d",SensorValue(motorEncoders[subMenuLevel]));
										displayLCDString(1,2,"            ");
										displayLCDString(1,(8-strlen(readoutString)%2) - (floor(strlen(readoutString)/2)),readoutString);
										motorSlewed(motorDefinitions[subMenuLevel], -50);
										loopCount = -25;
										while(nLCDButtons == leftButton) {
											stringFormat(readoutString,"%d",SensorValue(motorEncoders[subMenuLevel]));
											displayLCDString(1,2,"            ");
											displayLCDString(1,(8-strlen(readoutString)%2) - (floor(strlen(readoutString)/2)),readoutString);
											if(loopCount == 0) {
												displayLCDChar(0,1, downArrow);
											}
											else if(loopCount == 25) {
												displayLCDChar(1,1, downArrow);
											}
											else if(loopCount == 50) {
												displayLCDChar(0,1, clear);
											}
											else if(loopCount == 65) {
												displayLCDChar(1,1, clear);
											}
											else if(loopCount == 100) {
												loopCount = -1;
											}
											loopCount++;
											wait1Msec(10);
										}
										motorSlewed(motorDefinitions[subMenuLevel], 0);
									}
									else if(nLCDButtons == rightButton) {
										displayLCDChar(0,14, clear);
										displayLCDChar(0,14, upArrow);
										stringFormat(readoutString,"%d",SensorValue(motorEncoders[subMenuLevel]));
										displayLCDString(1,2,"            ");
										displayLCDString(1,(8-strlen(readoutString)%2) - (floor(strlen(readoutString)/2)),readoutString);
										motorSlewed(motorDefinitions[subMenuLevel], 50);
										loopCount = 35;
										while(nLCDButtons == rightButton) {
											stringFormat(readoutString,"%d",SensorValue(motorEncoders[subMenuLevel]));
											displayLCDString(1,2,"            ");
											displayLCDString(1,(8-strlen(readoutString)%2) - (floor(strlen(readoutString)/2)),readoutString);
											if(loopCount == 0) {
												displayLCDChar(1,14, upArrow);
											}
											else if(loopCount == 25) {
												displayLCDChar(0,14, upArrow);
											}
											else if(loopCount == 50) {
												displayLCDChar(1,14, clear);
											}
											else if(loopCount == 65) {
												displayLCDChar(0,14, clear);
											}
											else if(loopCount == 100) {
												loopCount = -1;
											}
											loopCount++;
											wait1Msec(10);
										}
										motorSlewed(motorDefinitions[subMenuLevel], 0);
									}
									else if(nLCDButtons == centerButton) {
										menuLevel = 0;
										displayLCDCenteredString(0, motorNames[subMenuLevel]);
										displayLCDCenteredString(1, "Select");
										displayLCDChar(1,0+subMenuLevel,leftArrow);
										displayLCDChar(1,12+subMenuLevel,rightArrow);
										wait1Msec(300);
										break;
									}
									wait1Msec(10);
								}
							}
							else if(subMenuLevel == 4) {
								clearLCDLine(0);
								clearLCDLine(1);
								displayLCDCenteredString(0,"Grip Control");
								displayLCDCenteredString(1, "Open");
								displayLCDChar(1,1, return_Arrow);
								delay(300);
								while(true) {
									if(nLCDButtons == centerButton) {
										if(gripState == 0) {
											gripState = 1;
											displayLCDCenteredString(1, "Close");
											displayLCDChar(1,1, return_Arrow);
											actuateClaw(35, 1);
										}
										else {
											gripState = 0;
											displayLCDCenteredString(1, "Open");
											displayLCDChar(1,1, return_Arrow);
											actuateClaw(35, 0);
										}
										delay(300);
									}
									else if(nLCDButtons == leftButton) {
										break;
									}
									delay(10);
								}
							}
							else if(subMenuLevel == 5) {
								clearLCDLine(0);
								clearLCDLine(1);
								displayLCDCenteredString(0, "Vacuum State");
								displayLCDChar(1, 1, 196);
								if(vacuumState == 0) {
									displayLCDString(1, 6, "OFF");
								}
								else if(vacuumState == 1) {
									displayLCDString(1, 6, " ON");
								}
								else {
									displayLCDCenteredString(1, "ERROR");
								}
								wait1Msec(300);
								while(true) {
									if(nLCDButtons == centerButton) {
										if(vacuumState == 0) {
											vacuumPower(1);
											displayLCDString(1, 6, " ON");
											wait1Msec(300);
										}
										else {
											vacuumPower(0);
											displayLCDString(1, 6, "OFF");
											wait1Msec(300);
										}
									}
									if(nLCDButtons == leftButton) {
										displayLCDCenteredString(0, "Vacuum State");
										displayLCDCenteredString(1, "Select");
										displayLCDChar(1,1,leftArrow);
										displayLCDChar(1,14,rightArrow);
										wait1Msec(300);
										break;
									}
									wait1Msec(10);
								}
							}
							else if(subMenuLevel == 6) {
								clearLCDLine(0);
								clearLCDLine(1);
								displayLCDCenteredString(0, "Vice State");
								displayLCDChar(1, 1, 196);
								if(viceState == 0) {
									displayLCDString(1, 4, "Released");
								}
								else if(vacuumState == 1) {
									displayLCDString(1, 4, "Clamped ");
								}
								else {
									displayLCDCenteredString(1, "ERROR");
								}
								wait1Msec(300);
								while(true) {
									if(nLCDButtons == centerButton) {
										if(viceState == 0) {
											actuateVice(1);
											displayLCDString(1, 4, "Clamped ");
											wait1Msec(300);
										}
										else {
											actuateVice(0);
											displayLCDString(1, 4, "Released");
											wait1Msec(300);
										}
									}
									if(nLCDButtons == leftButton) {
										displayLCDCenteredString(0, "Vice State");
										displayLCDCenteredString(1, "Select");
										displayLCDChar(1,1,leftArrow);
										displayLCDChar(1,14,rightArrow);
										wait1Msec(300);
										break;
									}
									wait1Msec(10);
								}
							}
							else if(subMenuLevel == 7) {
								subSubMenuLevel = 0;
								clearLCDLine(0);
								clearLCDLine(1);
								displayLCDCenteredString(0, "Cycle  Start");
								displayLCDCenteredString(1, "Send");
								displayLCDChar(1, 1, leftArrow);
								displayLCDChar(1, 14, rightArrow);
								wait1Msec(300);
								while(true) {
									if(nLCDButtons == rightButton && subSubMenuLevel < 2) {
										subSubMenuLevel++;
										if(subSubMenuLevel == 1) {
											displayLCDCenteredString(0, "Stop");
											displayLCDChar(1, 1, leftArrow);
											displayLCDChar(1, 14, rightArrow);
										}
										else if(subSubMenuLevel == 2) {
											displayLCDCenteredString(0, "Rewind");
											displayLCDCenteredString(1, "Send")
											displayLCDChar(1, 1, leftArrow);
											displayLCDChar(1, 14, rightArrow);
										}
										wait1Msec(300);
									}
									else if(nLCDButtons == leftButton && subSubMenuLevel > 0) {
										subSubMenuLevel--;
										if(subSubMenuLevel == 0) {
											displayLCDCenteredString(0, "Cycle  Start");
											displayLCDCenteredString(1, "Send")
											displayLCDChar(1, 1, leftArrow);
											displayLCDChar(1, 14, rightArrow);
										}
										else if(subSubMenuLevel == 1) {
											displayLCDCenteredString(0, "Stop");
											displayLCDCenteredString(1, "Send")
											displayLCDChar(1, 1, leftArrow);
											displayLCDChar(1, 14, rightArrow);
										}
										wait1Msec(300);
									}
									else if(nLCDButtons == 5) {
										displayLCDCenteredString(0, "Mill Interface");
										displayLCDCenteredString(1, "Select");
										displayLCDChar(1,1,leftArrow);
										displayLCDChar(1,14,rightArrow);
										wait1Msec(600);
										break;
									}
									else if(nLCDButtons == centerButton) {
										if(subSubMenuLevel == 0) {
											cycleStartMill();
										}
										else if(subSubMenuLevel == 1) {
											stopMill();
										}
										else if(subSubMenuLevel == 2) {
											rewindMill();
										}
										clearLCDLine(1);
										displayLCDChar(1,1,leftArrow);
										displayLCDChar(1,14,rightArrow);
										wait1Msec(300);
										displayLCDCenteredString(1,"Send");
										displayLCDChar(1,1,leftArrow);
										displayLCDChar(1,14,rightArrow);
									}
									wait1Msec(10);
								}
								wait1Msec(10);
							}
						}
						wait1Msec(10);
					}
				}
				wait1Msec(10);
			}
		}
	}
}
//Emergency Stop----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Emergency Stop
task emergencyStop() {
	while(true) {
		if(SensorValue(eStop) == 1) {
			waitUntil(SensorValue(eStop) == 0);
			while(true) {
				motor[rotationM] = 0;
				motor[mainArmM] = 0;
				motor[secondaryArmM] = 0;
				motor[effectorPitchM] = 0;
				motor[effectorYawM] = 0;
				motor[effectorClawM] = 0;
				if(SensorValue(eStop) == 1) {
					break;
				}
			}
		}
	delay(10);
	}
}
//Incoming Serial Data Handler------------------------------------------------------------------------------------------------------------------------------------------------------------------Incoming Serial Data Handler
task serialReceiveHandler() {
	while(true) {
		tentativeByte = getChar(UART1);
		if(tentativeByte >= 0) {
			clearLCDLine(0);
			clearLCDLine(1);
			incomingData[0] = tentativeByte;
			incomingData[1] = 0;
			incomingData[2] = 0;
			incomingData[3] = 0;
			incomingData[4] = 0;
			receiveSign = incomingData[0] / 10;
			receiveLength = incomingData[0] - (receiveSign * 10);
			if(receiveSign == 1) {
				receiveSign = -1;
			}
			else {
				receiveSign = 1;
			}
			byteCount = 1;
			while(byteCount < receiveLength + 2) {
				tentativeByte = getChar(UART1);
				if(tentativeByte >= 0) {
					incomingData[byteCount] = tentativeByte;
					byteCount++;
				}
			}
			receiveData = receiveSign * ((incomingData[4] * 10000) + (incomingData[3] * 100) + incomingData[2]);
			stringFormat(byteString, "%d", receiveData);
			//displayLCDCenteredString(0, byteString);
			receiveMeaning = incomingData[1];
			//displayLCDNumber(1,0,incomingData[0]);
			//	displayLCDNumber(1,3, incomingData[1]);
			//displayLCDNumber(1,6, incomingData[2]);
			//	displayLCDNumber(1,9, incomingData[3]);
			//	displayLCDNumber(1,12, incomingData[4]);
			displayLCDNumber(1,0, receiveMeaning);
			displayLCDNumber(1,4, receiveData);
			switch(receiveMeaning) {
			case 0:
				motorSlewed(rotationM, receiveData);
				break;
			case 1:
				motorSlewed(mainArmM, receiveData);
				break;
			case 2:
				motorSlewed(secondaryArmM, receiveData);
				break;
			case 3:
				motorSlewed(effectorYawM, receiveData);
				break;
			case 4:
				motorSlewed(effectorPitchM, receiveData);
				break;
			case 5:
				setPosistionFromSerial(home);
				break;
			case 6:
				setPosistionFromSerial(aboveVice);
				break;
			case 7:
				setPosistionFromSerial(vice);
				break;
			case 8:
				setPosistionFromSerial(abovePickup);
				break;
			case 9:
				setPosistionFromSerial(pickup);
				break;
			case 20:
				moveToDefinedPosistion(receiveData/100, receiveData - floor(receiveData/10), true);
				break;
			case 21:
				switch(receivedPosistions) {
				case 0:
					targetLocation[0] = receiveData;
					receivedPosistions++;
					break;
				case 1:
					targetLocation[1] = receiveData;
					receivedPosistions++;
					break;
				case 2:
					targetLocation[2] = receiveData;
					receivedPosistions++;
					break;
				case 3:
					targetLocation[3] = receiveData;
					receivedPosistions++;
					break;
				case 4:
					targetLocation[4] = receiveData;
					receivedPosistions++;
					break;
				case 5:
					targetLocation[5] = receiveData;
					receivedPosistions = 0;
					moveToUndefinedPosistion(targetLocation[0], targetLocation[1], targetLocation[2], targetLocation[3], targetLocation[4], targetLocation[5], true);
					break;
				}
			/*case 23:
				motor[effectorClawM] = receiveData;
				break;*/
			case 24:
				actuateVice(receiveData);
				break;
			case 25:
				cycleStartMill();
				break;
			case 26:
				runBatch(receiveData);
				break;
			case 27:
				actuateClaw(incomingData[3], incomingData[2]);
				break;
			}
		}
		delay(1);
	}
}
//Main------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------Main
task main() {
	bLCDBacklight = true;
	slaveMotor(mainArmSlaveM, mainArmM);
	flushSerialReceiveBuffer();
	startTask(lcdScreenControl);
	startTask(serialReceiveHandler);
	startTask(emergencyStop);
	sendNumber = 0;
	while(true) {
		sendSerial(0,0,nMotorEncoder(rotationM));
		sendSerial(0,1,nMotorEncoder(mainArmM));
		sendSerial(0,2,nMotorEncoder(secondaryArmM));
		sendSerial(0,3,nMotorEncoder(effectorYawM));
		sendSerial(0,4,nMotorEncoder(effectorPitchM));
	}
	/*while(true) {
		if(nLCDButtons == centerButton) {
			cycleStartMill();
		}
	}*/
}
